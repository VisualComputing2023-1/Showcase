<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Procedural texturing # Procedural texturing is a technique used in computer graphics to generate textures algorithmically, rather than relying on pre-made image textures. It involves using mathematical functions, noise algorithms, and procedural rules to create textures with intricate patterns, details, and variations. By defining rules and parameters, procedural texturing allows for the generation of endless variations of textures with high resolution and seamless tiling. This approach offers flexibility, scalability, and efficiency, as the textures can be generated in real-time and adapt to different resolutions and shapes."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Procedural texturing # Procedural texturing is a technique used in computer graphics to generate textures algorithmically, rather than relying on pre-made image textures. It involves using mathematical functions, noise algorithms, and procedural rules to create textures with intricate patterns, details, and variations. By defining rules and parameters, procedural texturing allows for the generation of endless variations of textures with high resolution and seamless tiling. This approach offers flexibility, scalability, and efficiency, as the textures can be generated in real-time and adapt to different resolutions and shapes."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing2023-1.github.io/Showcase/docs/procedural-texturing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T20:42:21-05:00"><title>Procedural Texturing | Visual Computing 2023-1</title><link rel=manifest href=/Showcase/manifest.json><link rel=icon href=/Showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/Showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/Showcase/flexsearch.min.js></script>
<script defer src=/Showcase/en.search.min.7cec9b0a1075c58a0c46780d1b5a27630bd03282c9eb859d249bcc11ec8e7b22.js integrity="sha256-fOybChB1xYoMRngNG1onYwvQMoLJ64WdJJvMEeyOeyI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/Showcase/><span>Visual Computing 2023-1</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/Showcase/docs/Color-blending/>Color Blending</a></li><li><a href=/Showcase/docs/Color-mapping/>Color Mapping</a></li><li><a href=/Showcase/docs/Color-models/>Color Models</a></li><li><a href=/Showcase/docs/Depth-Perception/>Depth Perception</a></li><li><a href=/Showcase/docs/procedural-texturing/ class=active>Procedural Texturing</a></li><li><a href=/Showcase/docs/Second-delivery/Photomosaic/Photomosaic/>Photomosaic</a></li><li><a href=/Showcase/docs/solar_system/>Solar System</a></li><li><a href=/Showcase/docs/Terrain-generation/>Terrain Generation</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/Showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Procedural Texturing</strong>
<label for=toc-control><img src=/Showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#procedural-texturing><strong>Procedural texturing</strong></a><ul><li><a href=#file-1-frag-file><strong>File #1: .frag file</strong></a></li><li><a href=#file2-vert-file><strong>File#2: .vert file</strong></a></li><li><a href=#file3-js-file><strong>File#3: .js file</strong></a></li><li><a href=#more-elaborated-exercises-about-procedural-texturing-after-previous-detailed-explanation><strong>More elaborated exercises about Procedural Texturing after previous detailed explanation:</strong></a><ul><li><a href=#second-exercise><strong>Second Exercise:</strong></a></li><li><a href=#third-exercise><strong>Third Exercise:</strong></a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=procedural-texturing><strong>Procedural texturing</strong>
<a class=anchor href=#procedural-texturing>#</a></h1><p>Procedural texturing is a technique used in computer graphics to generate textures algorithmically, rather than relying on pre-made image textures. It involves using mathematical functions, noise algorithms, and procedural rules to create textures with intricate patterns, details, and variations. By defining rules and parameters, procedural texturing allows for the generation of endless variations of textures with high resolution and seamless tiling. This approach offers flexibility, scalability, and efficiency, as the textures can be generated in real-time and adapt to different resolutions and shapes. Procedural texturing is widely used in various applications, including video games, virtual reality, visual effects, and computer-generated imagery, to create realistic, immersive, and visually compelling virtual environments.</p><p>The complete exposition will begin by an in-depth explanation about the first procedural texturing exercise that was elaborated by the team. It will allow us understand better two more exercises which are more complicated. So, the first procedural texturing exercise looks like:</p><p><strong>First Exercise:</strong></p><iframe height=470 width=100% src=https://editor.p5js.org/bchaparro/full/fv64R1A6n></iframe><p>In order to develop this animation it is needed three files:</p><h2 id=file-1-frag-file><strong>File #1: .frag file</strong>
<a class=anchor href=#file-1-frag-file>#</a></h2><p>A .frag file is a shader file used in computer graphics. It contains code for the fragment shader, which determines the color and other properties of pixels on the screen. It allows for precise control over pixel-level operations, enabling the creation of stunning visual effects and realistic rendering in graphics applications and games.</p><p>This code is a computer program that creates a visual pattern called a shader. A shader is like a special effect that is applied to a digital image or animation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>ifdef</span> <span style=color:#a6e22e>GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>precision</span> <span style=color:#a6e22e>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>uniform</span> <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>resolution</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>uniform</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>time</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>circle</span>(<span style=color:#66d9ef>in</span> <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>_st</span>, <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>_radius</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>_st</span><span style=color:#f92672>-</span><span style=color:#a6e22e>vec2</span>(<span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.</span><span style=color:#f92672>-</span><span style=color:#a6e22e>smoothstep</span>(<span style=color:#a6e22e>_radius</span><span style=color:#f92672>-</span>(<span style=color:#a6e22e>_radius</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0.01</span>),
</span></span><span style=display:flex><span>                         <span style=color:#a6e22e>_radius</span><span style=color:#f92672>+</span>(<span style=color:#a6e22e>_radius</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0.01</span>),
</span></span><span style=display:flex><span>                         <span style=color:#a6e22e>dot</span>(<span style=color:#a6e22e>l</span>,<span style=color:#a6e22e>l</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>4.0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>st</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gl_FragCoord</span>.<span style=color:#a6e22e>xy</span><span style=color:#f92672>/</span><span style=color:#a6e22e>resolution</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec3</span> <span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>st</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>3.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>st</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fract</span>(<span style=color:#a6e22e>st</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>(<span style=color:#a6e22e>st</span>,<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gl_FragColor</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(<span style=color:#a6e22e>color</span>,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s break down the code step by step:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>ifdef</span> <span style=color:#a6e22e>GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>precision</span> <span style=color:#a6e22e>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>endif</span>
</span></span></code></pre></div><p>These lines are what we call preprocessor directives. They are used to configure the code for a specific environment. In this case, it checks if we are using OpenGL ES (a graphics library) and sets the precision of floating-point numbers to medium.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>uniform</span> <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>u_resolution</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>uniform</span> <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>u_mouse</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>uniform</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>u_time</span>;
</span></span></code></pre></div><p>These lines declare some variables that the shader can use to interact with the outside world. u_resolution represents the resolution of the output image, u_mouse represents the position of the mouse (if available), and u_time represents the current time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>tile</span>(<span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>st</span>, <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>zoom</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>st</span> <span style=color:#f92672>*=</span> <span style=color:#a6e22e>zoom</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fract</span>(<span style=color:#a6e22e>st</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function takes a position (st) and a zoom level and creates a tiled pattern by multiplying the position by the zoom level and then taking the fractional part of it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>st</span>, <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>radius</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>pos</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec2</span>(<span style=color:#ae81ff>0.5</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>st</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>radius</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0.75</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.</span><span style=color:#f92672>-</span><span style=color:#a6e22e>smoothstep</span>(<span style=color:#a6e22e>radius</span><span style=color:#f92672>-</span>(<span style=color:#a6e22e>radius</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0.05</span>),<span style=color:#a6e22e>radius</span><span style=color:#f92672>+</span>(<span style=color:#a6e22e>radius</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0.05</span>),<span style=color:#a6e22e>dot</span>(<span style=color:#a6e22e>pos</span>,<span style=color:#a6e22e>pos</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>3.14</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function creates a circle shape. It takes a position (st) and a radius and calculates the distance from that position to the center. It then uses a smoothstep function to determine the opacity of the circle based on the distance.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>circlePattern</span>(<span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>st</span>, <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>radius</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>  <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>st</span><span style=color:#f92672>+</span><span style=color:#a6e22e>vec2</span>(<span style=color:#ae81ff>0.</span>,<span style=color:#f92672>-</span>.<span style=color:#ae81ff>5</span>), <span style=color:#a6e22e>radius</span>)<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>st</span><span style=color:#f92672>+</span><span style=color:#a6e22e>vec2</span>(<span style=color:#ae81ff>0.</span>,.<span style=color:#ae81ff>5</span>), <span style=color:#a6e22e>radius</span>)<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>st</span><span style=color:#f92672>+</span><span style=color:#a6e22e>vec2</span>(<span style=color:#f92672>-</span>.<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>0.</span>), <span style=color:#a6e22e>radius</span>)<span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>circle</span>(<span style=color:#a6e22e>st</span><span style=color:#f92672>+</span><span style=color:#a6e22e>vec2</span>(.<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>0.</span>), <span style=color:#a6e22e>radius</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function creates a pattern made up of multiple circles. It calls the circle function four times, each time with a slightly different position offset by 0.5 units in different directions. It then adds up the opacity values of the circles to create the final pattern.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>st</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gl_FragCoord</span>.<span style=color:#a6e22e>xy</span><span style=color:#f92672>/</span><span style=color:#a6e22e>u_resolution</span>.<span style=color:#a6e22e>xy</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>st</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>*=</span> <span style=color:#a6e22e>u_resolution</span>.<span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>u_resolution</span>.<span style=color:#a6e22e>y</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec3</span> <span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>grid1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(<span style=color:#a6e22e>st</span>,<span style=color:#ae81ff>7.</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>grid1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(<span style=color:#a6e22e>st</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>vec2</span>(<span style=color:#a6e22e>cos</span>(<span style=color:#a6e22e>u_time</span>),<span style=color:#a6e22e>sin</span>(<span style=color:#a6e22e>u_time</span>))<span style=color:#f92672>*</span><span style=color:#ae81ff>0.01</span>,<span style=color:#ae81ff>7.</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>color</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>mix</span>(<span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.075</span>,<span style=color:#ae81ff>0.114</span>,<span style=color:#ae81ff>0.329</span>),<span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.973</span>,<span style=color:#ae81ff>0.843</span>,<span style=color:#ae81ff>0.675</span>),<span style=color:#a6e22e>circlePattern</span>(<span style=color:#a6e22e>grid1</span>,<span style=color:#ae81ff>0.23</span>)<span style=color:#f92672>-</span><span style=color:#a6e22e>circlePattern</span>(<span style=color:#a6e22e>grid1</span>,<span style=color:#ae81ff>0.01</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vec2</span> <span style=color:#a6e22e>grid2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(<span style=color:#a6e22e>st</span>,<span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>grid2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(<span style=color:#a6e22e>st</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>vec2</span>(<span style=color:#a6e22e>cos</span>(<span style=color:#a6e22e>u_time</span>),<span style=color:#a6e22e>sin</span>(<span style=color:#a6e22e>u_time</span>))<span style=color:#f92672>*</span><span style=color:#ae81ff>0.02</span> ,<span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mix</span>(<span style=color:#a6e22e>color</span>, <span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.761</span>,<span style=color:#ae81ff>0.247</span>,<span style=color:#ae81ff>0.102</span>), <span style=color:#a6e22e>circlePattern</span>(<span style=color:#a6e22e>grid2</span>,<span style=color:#ae81ff>0.2</span>)) <span style=color:#f92672>-</span> <span style=color:#a6e22e>circlePattern</span>(<span style=color:#a6e22e>grid2</span>,<span style=color:#ae81ff>0.05</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gl_FragColor</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(<span style=color:#a6e22e>color</span>,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is the main part of the code, where the shader is constructed. The main function is the entry point of the shader.</p><ul><li>It starts by calculating the normalized screen coordinates (st) based on the current pixel&rsquo;s position (gl_FragCoord) and the resolution (u_resolution).</li><li>It then adjusts the x-coordinate of st to account for the aspect ratio of the output image.</li><li>A color variable is initialized to black (vec3(0.0)).</li><li>The tile function is called twice to generate two different grid patterns (grid1 and grid2) using different zoom levels (7 and 3, respectively).</li><li>The circlePattern function is used to create two different circle patterns using the generated grids and different radii.</li><li>The resulting patterns are mixed with specific colors using the mix function and added to the color variable.</li><li>Finally, the color value is assigned to gl_FragColor, which represents the color of the current pixel.</li></ul><h2 id=file2-vert-file><strong>File#2: .vert file</strong>
<a class=anchor href=#file2-vert-file>#</a></h2><p>A .vert file is a shader file used in computer graphics. It contains code for the vertex shader, which transforms individual vertices of 3D objects. It customizes geometry, lighting, and appearance, shaping visually stunning graphics in applications and games.</p><p>This vertex shader takes the input vertex positions, transforms them by scaling and shifting to normalize the coordinates, and assigns the final position to gl_Position. This prepares the vertices for further processing in the subsequent stages of the graphics pipeline.</p><p>The complete code looks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>attribute</span> <span style=color:#a6e22e>vec3</span> <span style=color:#a6e22e>aPosition</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vec4</span> <span style=color:#a6e22e>positionVec4</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(<span style=color:#a6e22e>aPosition</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>positionVec4</span>.<span style=color:#a6e22e>xy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>positionVec4</span>.<span style=color:#a6e22e>xy</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>gl_Position</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>positionVec4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The detailed explanation begins with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>attribute</span> <span style=color:#a6e22e>vec3</span> <span style=color:#a6e22e>aPosition</span>;
</span></span></code></pre></div><p>This line declares an attribute variable named aPosition, which represents the vertex positions of the object. It is of type vec3, indicating that it consists of three components (x, y, and z).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
</span></span></code></pre></div><p>This is the entry point of the vertex shader, where the main function starts.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>vec4</span> <span style=color:#a6e22e>positionVec4</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(<span style=color:#a6e22e>aPosition</span>, <span style=color:#ae81ff>1.0</span>);
</span></span></code></pre></div><p>This line creates a vec4 variable called positionVec4 and assigns the aPosition values to its x, y, and z components. The w component is set to 1.0, which is often used for position calculations in homogeneous coordinates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>positionVec4</span>.<span style=color:#a6e22e>xy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>positionVec4</span>.<span style=color:#a6e22e>xy</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span></code></pre></div><p>Here, the x and y components of positionVec4 are transformed. They are multiplied by 2.0 to scale the values, and then 1.0 is subtracted to shift them to the range of -1.0 to 1.0. This is a common normalization step to map vertex positions to screen coordinates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>gl_Position</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>positionVec4</span>;
</span></span></code></pre></div><p>The final transformed position in positionVec4 is assigned to the built-in variable gl_Position. This variable represents the final position of the vertex on the screen.</p><h2 id=file3-js-file><strong>File#3: .js file</strong>
<a class=anchor href=#file3-js-file>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>theShader</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>shaderTexture</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>theta</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>outsideRadius</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>insideRadius</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>(){
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>theShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadShader</span>(<span style=color:#e6db74>&#39;shader.vert&#39;</span>,<span style=color:#e6db74>&#39;shader.frag&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#a6e22e>innerWidth</span>, <span style=color:#a6e22e>innerHeight</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderTexture</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#ae81ff>710</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderTexture</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>theShader</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>theShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;resolution&#34;</span>, [<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>]);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>theShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;time&#34;</span>, <span style=color:#a6e22e>millis</span>() <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000.0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>theShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;mouse&#34;</span>, [<span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>mouseY</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>height</span>, <span style=color:#ae81ff>0</span>)]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shaderTexture</span>.<span style=color:#a6e22e>rect</span>(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#a6e22e>width</span>,<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>216</span>, <span style=color:#ae81ff>233</span> );
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texture</span>(<span style=color:#a6e22e>shaderTexture</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>push</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rotateZ</span>(<span style=color:#a6e22e>theta</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.0001</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rotateX</span>(<span style=color:#a6e22e>theta</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.0001</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rotateY</span>(<span style=color:#a6e22e>theta</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.0001</span>);  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>theta</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.05</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ellipsoid</span>(<span style=color:#ae81ff>30</span><span style=color:#f92672>*</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>40</span><span style=color:#f92672>*</span><span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>40</span><span style=color:#f92672>*</span><span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pop</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, we have some variable declarations. Think of variables as containers that hold values. In this code, we have variables called theShader, shaderTexture, theta, x, y, outsideRadius, and insideRadius. These variables will be used to store different kinds of information that the code needs.</p><p>Next, we have a function called preload(). This function is used to load external resources before the program starts running. In this case, it&rsquo;s loading a shader file, which is a special type of program used for rendering graphics.</p><p>Moving on to the setup() function. This function is called once at the beginning of the program. It&rsquo;s used to initialize and set up things before the main part of the program starts running. Here, we&rsquo;re creating a canvas (a drawing area) that fills the entire browser window, using the createCanvas() function. We&rsquo;re also creating a graphics object called shaderTexture with a width of 710 pixels and a height of 400 pixels.</p><p>After that, we set the initial values of x and y variables to -50 and 0 respectively.</p><p>Now, let&rsquo;s look at the draw() function. This function is called repeatedly in a loop after the setup() function. It&rsquo;s where the main drawing and animation happens.</p><p>Inside the draw() function, we first tell the shaderTexture graphics object to use the theShader shader that we loaded earlier. This shader will be applied to the graphics object when we draw something on it.</p><p>Next, we set some uniform variables in the shader. Think of uniform variables as values that can be accessed by the shader program. Here, we&rsquo;re setting the resolution uniform to the width and height of the canvas, the time uniform to the current time in seconds, and the mouse uniform to the current mouse position.</p><p>Then, we draw a rectangle on the shaderTexture graphics object. This rectangle will be affected by the shader we set earlier.</p><p>After that, we set the background color of the canvas to a light pink color.</p><p>Next, we set the texture of the shapes we&rsquo;re going to draw to be the shaderTexture graphics object, so the shader effect will be applied to the shapes.</p><p>Now, we start a new drawing state using the push() function. This allows us to apply transformations (like rotation) to the shapes without affecting other shapes drawn after it.</p><p>We apply rotations to the shapes based on the theta variable and the position of the mouse. This creates an animated effect where the shapes rotate. The theta variable is incremented by 0.05 each time draw() is called, which makes the rotation change over time.</p><p>Finally, we draw an ellipsoid (a three-dimensional shape similar to a sphere, but stretched) with specific dimensions.</p><p>That&rsquo;s it! The code continuously repeats the draw() function, creating an animated and interactive visual effect.</p><h2 id=more-elaborated-exercises-about-procedural-texturing-after-previous-detailed-explanation><strong>More elaborated exercises about Procedural Texturing after previous detailed explanation:</strong>
<a class=anchor href=#more-elaborated-exercises-about-procedural-texturing-after-previous-detailed-explanation>#</a></h2><h3 id=second-exercise><strong>Second Exercise:</strong>
<a class=anchor href=#second-exercise>#</a></h3><iframe height=490 width=100% src=https://editor.p5js.org/bchaparro/full/sOBs9Z5aF></iframe><h3 id=third-exercise><strong>Third Exercise:</strong>
<a class=anchor href=#third-exercise>#</a></h3><iframe height=470 width=100% src=https://editor.p5js.org/bchaparro/full/a9utVqv-P></iframe></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/VisualComputing2023-1/Showcase/commit/9c3a802dead34aec112764e68d8b5f6aadb3e8ee title='Last modified by Brian Chaparro Cetina | June 20, 2023' target=_blank rel=noopener><img src=/Showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 20, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#procedural-texturing><strong>Procedural texturing</strong></a><ul><li><a href=#file-1-frag-file><strong>File #1: .frag file</strong></a></li><li><a href=#file2-vert-file><strong>File#2: .vert file</strong></a></li><li><a href=#file3-js-file><strong>File#3: .js file</strong></a></li><li><a href=#more-elaborated-exercises-about-procedural-texturing-after-previous-detailed-explanation><strong>More elaborated exercises about Procedural Texturing after previous detailed explanation:</strong></a><ul><li><a href=#second-exercise><strong>Second Exercise:</strong></a></li><li><a href=#third-exercise><strong>Third Exercise:</strong></a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>